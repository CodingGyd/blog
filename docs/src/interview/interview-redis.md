---
title: Redis常见面试题
shortTitle: Redis常见面试题
date: 2023-10-26
category:
  - 微服务中间件
description: 收集中间件Redis的常用面试题
head:
  - - meta
    - name: keywords
      content: Redis,非关系型数据库,缓存,NoSQL,分布式缓存,集群,哨兵
---


# Redis 

## 一、前言

Redis的相关知识在Java程序员的面试过程中是必问的，本文将持续收集最新的Redis常见面试题，希望能给即将或正在找工作的技术小伙伴们带来一些帮助，如果有用记得关注+收藏+点赞哦!



## 二、经典面试题-基础概念篇

### 1、介绍一下Redis是什么?

据说有一名意大利程序员，在 2004 年到 2006 年间主要做嵌入式工作，之后接触了 Web，2007 年和朋友共同创建了一个网站，并为了解决这个网站的负载问题（为了避免 MySQL 的低性能），于是亲自定做一个数据库，并于 2009 年开发完成，这个就是 Redis。这个意大利程序员就是 Salvatore Sanfilippo 江湖人称 Redis 之父，大家更习惯称呼他 Antirez。

Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。Redis属于非关系型数据库中的一种解决方案，目前也是业界主流的缓存解决方案组件。

数百万开发人员在使用Redis用作数据库、缓存、流式处理引擎和消息代理。

### 2、介绍一下Redis的功能模块架构

![主要模块划分](http://cdn.gydblog.com/images/middleware/redis-jg-6.jpg)

> 网络访问框架

​    通过网络框架以 Socket 通信的形式对外提供键值对操作，包括socket服务和协议解析。客户端发送命令时，命令会被封装成网络请求传输给redis。

> 操作模块

主要对各种数据进行操作，如get 、put 、delete 、scan操作等。

> 索引模块

索引模块主要目的是为了通过key值快速定位value值，从而进行操作。 redis使用的索引模块为哈希表。redis存储内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。

> 存储模块

主要完成保存数据的工作，存储数据模型为 key-value形式，value支持丰富的数据类型。包括字符串，列表 ，哈希表，集合等。不同的数据类型能支持不同的业务需求。

其中的持久化模块主要对数据进行持久化，当系统重启时，能够快速恢复服务。redis的持久化策略分为：日志（AOF）和快照（RDB）两种方式，新版本增加了混合模式。

> 高可用模块

主从复制：主从架构中用到（一个Master至少一个slave），master -> slave 数据复制 

哨兵：主从架构实现高可用（一个Master至少一个slave），在master故障的时候，快速将slave切换成master，实现快速的灾难恢复，实现高可用性；

> 高扩展模块

Redis Cluster（分片集群）是Redis提供的分布式高可扩展解决方案。

切片集群，也叫分片集群（集群分片），就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。

> 其它模块

还有一些其他模块，例如：数据压缩、过期机制、数据淘汰策略、主从复制、集群化、高可用等功能，另外还可以增加统计模块、通知模块、调试模块、元数据查询等辅助功能。



### 3、说说Redis的部署方式

截至目前，Redis支持四种部署架构，分别是单机、主从、哨兵、集群。

> 单机

![单机架构](http://cdn.gydblog.com/images/middleware/redis-jg-1.png)

单机模式是最原始的模式，非常简单，就是安装运行一个Redis实例，然后业务项目调用即可。

单机有宕机的风险，可用性保证差。一些非常简单的应用，并非必须保证高可用的情况下完全可以使用该模式。

单机 Redis 能够承载的 QPS（每秒查询速率）取决于业务操作的复杂性。假如是简单的 key value 查询那性能就会很高，单机能支持10W+的QPS。如果是Lua 脚本，则性能会差。

> 主从

![主从架构](http://cdn.gydblog.com/images/middleware/redis-jg-2.png)

我们可以同时部署多个Redis，把同时接收读/写操作的节点称为Master(主节点), 接收读操作和数据同步的节点称为Slave(从节点)。

只要主从节点之间的网络连接正常，主节点就会将写入自己的数据同步更新给从节点，从而保证主从节点的数据一致性。

主从架构比较适合读高并发场景，当QPS增加时，水平扩展从节点即可。

主从架构存在的问题是：高可用性不够，当主节点宕机，需要在众多从节点中选一个作为新的主节点，同时需要修改客户端保存的主节点信息并重启客户端，还需要通知所有的从节点去复制新的主节点数据，从而保证服务的高可用性。整个切换过程需要人工干预，而这个过程很明显会造成服务的短暂不可用。

> 哨兵

Redis2.8支持了哨兵架构，它主要解决了主从架构中存在的高可用性问题，在**主从架构的基础**上，哨兵架构实现了**自动化故障检测和恢复机制**，全过程无需人工干预。

![哨兵架构](http://cdn.gydblog.com/images/middleware/redis-jg-3.png)

如上图所示，哨兵架构由两部分集群组成，哨兵节点集群和数据节点集群：

- 哨兵节点集群

  该集群中的节点不存储数据，是特殊的redis节点，主要完成监控、提醒、自动故障转移这三大功能。

  1）监控(Monitoring)：哨兵节点会不断地发送ping消息检测数据节点是否正常；

  2）提醒(Notification)：当监控到某个数据节点有问题时， 哨兵可以通过 API 向管理员或者其他应用程序发送通知

  3）自动故障迁移(Automatic failover)：当一个主数据节点不能正常工作时， 哨兵会开始一次自动故障迁移操作，将该主节点下线，选举一个从数据节点升级为主节点（这里也就是将主从架构中的人工干预过程自动化），同时通知客户端更新主从地址信息

- 数据节点集群

  该集群中的节点分为主从模式，都存储业务数据，这块其实就是之前的主从架构模式部分



哨兵模式部署成本高，需要单独维护一套哨兵集群，且它依旧没有解决主数据节点的写压力，主节点写的能力和存储能力依旧受限单机限制。另外，这种模式下的动态扩容变得更加复杂。

> 集群

Redis 3.0 版本正式推出 **Redis Cluster 集群**模式，有效地解决了 Redis 分布式方面的需求。Redis Cluster 集群模式具有**高可用**、**可扩展性**、**分布式**、**容错**等特性。

![集群架构](http://cdn.gydblog.com/images/middleware/redis-jg-4.png)

如上图所示，Redis的集群模式采用的是无中心多节点结构，节点数量至少为 6 个才能保证组成完整高可用的集群，其中三个为主节点，三个为从节点。三个主节点会分配槽，处理客户端的命令请求，而从节点可用在主节点故障后，顶替主节点。

**每个节点都可以保存部分数据**和整个集群状态，每个节点都和其他所有节点连接（采用 Gossip 协议进行通信，交换维护节点元数据信息），主从节点之间会进行数据复制。 



### 4、说说Redis的基本数据类型有哪些？

redis中支持的数据类型主要分为三大类：五大基本数据类型、三大扩展数据类型、自定义数据类型：

 ![数据类型分类](http://cdn.gydblog.com/images/middleware/redis-datatypes.png)

Redis 所有的数据结构都是以唯一的key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。



### 5、Redis为什么这么快？

从几个方面展开回答：

- 基于纯内存操作

  CPU不是 Redis性能瓶颈,，Redis的瓶颈是**机器内存**和*网络带宽*。

- 使用IO多路复用模型，非阻塞IO

   ![IO模型](http://cdn.gydblog.com/images/middleware/redis-interview.png)

- 高效的数据结构，对数据的操作比较简单



### 6、介绍Redis的内存清理策略

*redis对于已过期的key，有下面两种清理策略：*

- 定期删除

   redis 会将每个设置了过期时间的 key 放入到一个独立的字典中，以后会从字典中根据某种策略抽取一些key检查是否到期，已到期就删除。常用策略有no-envicition、allkeys-random、allkeys-lru、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lfu

   算法

- 惰性删除

   惰性策略就是在客户端访问这个key的时候，redis对key的过期时间进行检查，如果过期了就立即删除。

### 7、说说Redis的持久化机制

Redis 提供了两种持久化的方式，分别是**RDB**（Redis DataBase）和**AOF**（Append Only File）。

RDB：定期将 redis 某一时刻的数据持久化到磁盘中，是一种快照式的持久化方法。

AOF：将 redis 执行过的所有写指令记录到文件中，在下次 redis 重新启动时，只要把这些写指令按先后顺序再重复执行一遍，就可以实现数据恢复了。

官方的建议是两种持久化方式同时使用，这样可以提供更可靠的持久化方案。在这种情况下，如果 redis 重启的话，则会优先采用 AOF 方式来进行数据恢复，这是因为 AOF 方式的数据恢复完整度更高。

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。



### 8、Redis支持事务吗？

说到事务，大家可能最先想到的就是关系型数据库中的事务管理。Redis也支持事务，和关系型数据库的事务有类似的特点：

-  隔离性：事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
-  原子性：事务是一个原子操作，事务中的命令要么全部被执行，要么全部都不执行。

但是redis的事务和关系型数据库的事务有一个最大的区别：redis事务不会回滚，即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行完毕。

MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。MULTI负责开启事务，EXEC负责执行事务中的命令，DISCARD负责清空事务中的命令队列并放弃执行当前事务，WATCH来监控某个键是否被修改。

## 三、经典面试题-应用场景篇

### 1、谈谈客户端请求Redis的执行过程

从提交命令到获得命令结果经历的步骤



### 2、Redis在高并发场景下可能会出现什么问题?

解释缓存穿透、缓存击穿、缓存雪崩

#### 2.1 缓存穿透

**一句话概括：穿过 Redis 和数据库**

**展开说说：**

下面这段逻辑我们应该经常遇到：先去 Redis 中查找某数据，Redis 中查不到就去 DB 中查，DB 中查到后回写一份数据到 Redis 中。

![](http://cdn.gydblog.com/images/middleware/redis-interview-1.jpg)

上面这段逻辑正常情况下问题并不大，但是如果是在高并发场景下或者某个用户恶意重复请求某个不存在的数据A，那么每次请求都会直接穿过Redis组件并触达到 DB 上，严重时会导致数据库连接资源耗尽然后宕机。

因此，为了预防上述情况， 当Redis 和数据库中都没有我们想要的数据时，就需要考虑缓存穿透的问题了。

**常见缓存穿透的解决方案：**

- 缓存空值
- 请求合法性校验
- 布隆过滤器

#### 2.2 缓存击穿

**一句话概括：大家都盯着一个key往死里整。**

***展开说说：**

当某个业务是高并发场景时，大量请求同时请求同一个数据，而此时Redis 中该数据在此刻正好过期了，那么无数的请求则直接打到了后面的数据库 上，那么DB由于连接资源有限，被瞬间耗尽 ，后果不用想，DB肯定会挂。

**常见缓存击穿的解决方案：**

- 使用互斥锁
- 热点key永不过期
- 后台续命（后台开一个定时任务，专门主动更新即将过期的数据。相当于让key永不过期）

#### 2.3 缓存雪崩

**一句话概括：Redis挂了，或者数据都同时过期**

**展开说说：**

在某个时刻 Redis 服务实例挂了，或者Redis中的热点 key 都过期（失效）了。如果集群中的热点 key 在某一时刻同时失效了的话，同时海量的请求都将直接打到 DB 上，DB 就很可能会被击垮。

**常见缓存雪崩的解决方案：**

- 热点key永不过期

- key的 失效时间加上随机数

- 限流器+本地缓存

  

### 3、说说热Key问题和解决方案

答案来源：[如何找出优化大Key与热Key,产生的原因和问题_云数据库 Redis-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys)

**一句话概括：请求到的分片过于集中，超过单台Server的性能极限。**

**展开说说：**

在服务端读数据进行访问时，往往会对数据进行分片切分（集群方案）。此过程中会在某一主机Server上对相应的Key进行访问，当访问超过Server极限时，就会导致热点 Key 问题的产生。

通常以其接收到的Key被请求频率来判定是否是热key，例如：

- QPS集中在特定的Key：Redis实例的总QPS（每秒查询率）为10,000，而其中一个Key的每秒访问量达到了7,000。
- 带宽使用率集中在特定的Key：对一个拥有上千个成员且总大小为1 MB的HASH Key每秒发送大量的**HGETALL**操作请求。
- CPU使用时间占比集中在特定的Key：对一个拥有数万个成员的Key（ZSET类型）每秒发送大量的**ZRANGE**操作请求。

**带来的问题：**

- 占用大量的CPU资源，影响其他请求并导致整体性能降低。
- 集群架构下，产生访问倾斜，即某个数据分片被大量访问，而其他数据分片处于空闲状态，可能引起该数据分片的连接数被耗尽，新的连接建立请求被拒绝等问题。
- 在抢购或秒杀场景下，可能因商品对应库存Key的请求量过大，超出Redis处理能力造成超卖。
- 热Key的请求压力数量超出Redis的承受能力易造成缓存击穿，即大量请求将被直接指向后端的存储层，导致存储访问量激增甚至宕机，从而影响其他业务。

**常见热key问题解决方案：**

- 服务端增加本地缓存
- 热点key打撒到其它分片节点
- 使用读写分离架构

### 4、说说大Key问题和解决方案

答案来源：[如何找出优化大Key与热Key,产生的原因和问题_云数据库 Redis-阿里云帮助中心 (aliyun.com)](https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys)

**一句话概括：单个简单的key存储的value很大**

**展开说说：**

业务场景中经常会有各种大key的情况， 比如：
1）单个简单的key存储的value很大（例如排行榜信息，key是固定的，value排行榜几十万的数据）
2）hash、set、zset、list中存储过多的元素（以万为单位）

通常以Key的大小和Key中成员的数量来综合判定是否是大key，例如：

- Key本身的数据量过大：一个String类型的Key，它的值为5 MB。
- Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。
- Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。

**带来的问题：**

- 客户端执行命令的时长变慢。
- Redis内存达到**maxmemory**参数定义的上限引发操作阻塞或重要的Key被逐出，甚至引发内存溢出（Out Of Memory）。
- 集群架构下，某个数据分片的内存使用率远超其他数据分片，无法使数据分片的内存资源达到均衡。
- 对大Key执行读请求，会使Redis实例的带宽使用率被占满，导致自身服务变慢，同时易波及相关的服务。
- 对大Key执行删除操作，易造成主库较长时间的阻塞，进而可能引发同步中断或主从切换

**常见大key问题解决方案：**

- 拆分大key为多个小key，使用multiGet获取值
- 定期对过期的大key进行清理
- 监控Redis的内存水位，提前预防问题

### 5、用过Redis的分布式锁吗？

Redis实现分布式锁有多种方案：

- 方案一：SETNX + EXPIRE

  EXPIRE操作可能失败导致锁永远得不到释放

- 方案二：SETNX + value值是（系统时间+过期时间）

  依赖每个客户端的时间设置，必须要求分布式环境下，每个客户端的时间必须同步。

  当前客户端获得的锁可能被别的客户端释放/解锁。

  当前客户端锁的过期时间，可能被别的客户端覆盖。

  

- 方案三：使用Lua脚本(包含SETNX + EXPIRE两条指令)

- 方案四：SET的扩展命令（SET EX PX NX）

- 方案五：SET EX PX NX  + 校验唯一随机值,再释放锁

- 方案六: 开源框架~Redisson

- 方案七：多机实现的分布式锁Redlock

###  6、如何保证Redis和数据库的双写一致性

首先要坚持一个观点：没有任何技术方案可以保证Redis和数据库的实时双写一致，都只能做到最终一致性。

保证双写一致性，可选的方案有：更新数据库 + 更新缓存、更新数据库 + 删除缓存

- 更新数据库 + 更新缓存方案

  在并发情况下无法保证缓存和数据一致性，且存在缓存资源浪费和机器性能浪费的情况发生

- 更新数据库 + 删除缓存方案

  先删除缓存，再更新数据库在并发情况下依旧有数据不一致问题，解决方案是延迟双删，但这个延迟时间很难评估，所以推荐用先更新数据库，再删除缓存的方案；
  在先更新数据库，再删除缓存方案下，为了保证两步都成功执行，需配合消息队列或订阅变更日志的方案来做，本质是通过重试的方式保证数据一致性



## 四、更多面试题

前面列出的面试题是小郭目前熟知的知识，还比较少。

下面这个链接里是是某位大佬整理的非常全的面试题，小郭已经收藏慢慢看了，推荐大家也可以收藏一下。

推荐大佬的面试宝库：[JavaFamily/docs/all/缓存/redis at master · AobingJava/JavaFamily (github.com)](https://github.com/AobingJava/JavaFamily/tree/master/docs/all/缓存/redis)
