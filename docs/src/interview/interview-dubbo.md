---
# icon: lock
date: 2024-04-25
category:
  - 技术题库
tag:
  - Dubbo
---

# Dubbo

## 1、解释一下RPC和HTTP的区别
RPC是Remote Procedure Call 远程过程调用的缩写，要想实现RPC通常需要包含传输协议和序列化协议。  
而我们熟悉的HTTP，其实是一种超文本传输协议，RPC和HTTP不是同一个维度上的概念，只不过他们都是用来实现远程调用的，所以经常被拿来对比。  

RPC适用于内部服务之间的相互调用，性能好，传输效率高，服务治理效果好。  
而HTTP适合外部系统对接，比如浏览器访问、APP后端接口调用、三方接口对接等。  

## 2、说说dubbo的优雅停机
Dubbo是通过jdk的shutdownhook来实现优雅停机的。  
服务提供者，先将应用下线，标记为不接受请求，然后检查线程池中是否有正在运行的线程，若有，等待执行完成。  
服务消费者，不再发起新的调用请求，若有新发起，直接在客户端侧报错，检查是否有正在远程调用的请求，若有已经发起且正在等待响应的，则等待响应完成。  


## 3、dubbo支持哪些协议？
dubbo支持9种协议，包括dubbo（默认协议）、rmi、http、hessian、redis、memcached、thrift、webservice、restful这些协议。  
dubbo协议的特点是：单一长连接，TCP协议传输，NIO异步通信，适合并发量高且数据传输量小的场景以及消费者远多于提供者的场景。  
其它协议的特点不需要死记硬背。  

## 4、dubbo的缓存机制了解吗？
dubbo支持客户端缓存和服务端缓存。  
服务端缓存指的是将响应结果保存到服务端内存，下一次相同调用直接从内存中获得缓存并返回，支持多种缓存方式：LRU、ThreadLocal等等。  
客户端缓存是指将远程调用服务方法的返回结果缓存到客户端内存，下次请求时直接从缓存中获取结果，而不必再调用远程服务方法。  
缓存的目的都是为了减少重复调用和网络IO次数，提高系统响应性能。  

## 5、dubbo如何实现像本地方法一样调用远程方法的？
Dubbo实现像本地方法一样调用远程方法的核心技术是动态代理。Dubbo使用JDK动态代理或者字节码增强技术，基于本地接口生成了一个代理类，这个代理类具有本地接口的所有方法。在调用本地接口方法时，就会通过代理类的invoke方法将请求转发到远程服务提供者上。这个过程包含了一系列环节：生成代理类、序列化和反序列化、网络通信、服务注册与发现、负载均衡、远程服务执行。    
**生成代理类**：dubbo在启动时会扫描配置文件（注解）中指定的服务接口，并根据服务接口生成一个代理类。这个代理类实现了服务接口，并且在调用服务接口的方法时，会将参数封装为请求消息，然后通过忘了传输给服务提供方。  
**序列化与反序列化**：为了在网络上发送和接收数据，Dubbo会将方法调用的参数和返回值进行序列化（转换为字节序列）和反序列化（从字节序列还原为数据）。这里面可以使用多种序列化协议：如hessian、jdk自带的序列化、json等。  
**网络通信**: dubbo支持多种通信协议，例如dubbo、http、rmi、redis、webservice、thrift、hessian等等协议，默认是dubbo协议。dubbo会根据协议的不同，选择不同的序列化方式，将请求消息序列化成二进制流并发送给服务提供方。  
**服务注册与发现**：dubbo使用注册中心（zookeeper、nacos等）来管理服务的提供者和消费者的元数据信息。服务提供者在启动时将自己提供的服务地址信息注册到注册中心，服务消费者通过注册中心查找所需的服务并获取服务提供者的地址，然后通过一系列策略（轮询、一致性哈希、随机）将业务请求路由到目标服务提供者地址。  
**负载均衡**： dubbo支持多种负载均衡算法，包括轮询、随机、加权随机、最小活跃数等，在客户端发起调用时，Dubbo会根据负载均衡算法选择一台服务提供者进行调用。
**远程服务执行**：当客户端发起远程调用时，服务提供方接收到请求后，会根据请求的服务接口名和方法，找到对应的实现类和方法，并将请求消息反序列化成参数列表，最终调用服务实现类的方法，并将执行结果序列化成响应消息返回给客户端。  

## 6、说说对dubbo的了解

从历史发展的角度来答：阿里巴巴开源的一个基于 Java 的 RPC 框架，在2017年重新开始维护，并且在 2018 年和当当的 Dubbox 进行了合并，进入 Apache 孵化器，在 2019 年毕业正式成为 Apache 顶级项目。 Dubbo 社区主力维护的是 2.6.x 和 2.7.x 两大版本，2.6.x 版本主要是 bug 修复和少量功能增强为准，是稳定版本。最新的 3.0 版本往云原生方向上探索着。

从总体架构的角度维护：分为如下角色节点

| 节点      | 角色说明                     |
| :-------- | :--------------------------- |
| Consumer  | 需要调用远程服务的服务消费方 |
| Registry  | 注册中心                     |
| Provider  | 服务提供方                   |
| Container | 服务运行的容器               |
| Monitor   | 监控中心                     |



## 7、说下服务暴露和引用的流程？

Dubbo的服务暴露和引用流程主要分为下面的步骤：

- Provider(提供者)绑定指定端口并启动服务；
- 指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储；
- Consumer(消费者），连接注册中心，并发送应用信息、所求服务信息至注册中心；
- 注册中心根据消费者所求服务信息匹配对应的提供者列表发送至Consumer应用缓存；
- Consumer在发起远程调用时基于缓存的消费者列表择其一发起调用；
- Provider状态变更会实时通知注册中心、在由注册中心实时推送至Consumer。

源码层面服务暴露的流程如下：

![服务暴露主要流程](http://cdn.gydblog.com/images/dubbo/dubbo-1.png)



服务暴露的底层代码实现层面则是主要下面两个步骤：

- 将持有的服务实例通过代理转换为Invoker对象（它的实现可能是本地、远程、集群这三种）

- 将Invoker通过具体的协议（比如Dubbo框架中的Dubbo协议）转换为Exporter

  

源码层面服务发现的流程如下：

![服务暴露主要流程](http://cdn.gydblog.com/images/dubbo/dubbo-2.png)

服务暴露的底层代码实现层面分为下面两个步骤：

- 通过持有的远程服务实例来生成Invoker，即远程代理对象
- 把Invoker通过动态代理转换成实现用户接口的动态代理引用



## 8、Dubbo中的SPI机制

Dubbo 中的扩展能力是从 JDK 标准的 SPI 扩展点发现机制加强而来。  



![dubbo的SPI流程](http://cdn.gydblog.com/images/dubbo/dubbo-spi-1.png)



通过SPI思想，用户能够基于 Dubbo 提供的扩展能力，很方便基于自身需求扩展其他协议、过滤器、路由等。



![dubbo的扩展点能力](http://cdn.gydblog.com/images/dubbo/dubbo-spi-2.png)



Dubbo 扩展能力使得 Dubbo 项目很方便的切分成一个一个的子模块，实现热插拔特性。用户完全可以基于自身需求，替换 Dubbo 原生实现，来满足自身业务需求。



Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下。

## 9、如何设计一个RPC框架

**可以从底层向上开始说起**。

首先需要实现高性能的网络传输，可以采用 Netty 来实现，不用自己重复造轮子，然后需要自定义协议，毕竟远程交互都需要遵循一定的协议，然后还需要定义好序列化协议，网络的传输毕竟都是二进制流传输的。

然后可以搞一套描述服务的语言，即 IDL（Interface description language），让所有的服务都用 IDL 定义，再由框架转换为特定编程语言的接口，这样就能跨语言了。

此时最近基本的功能已经有了，但是只是最基础的，工业级的话首先得易用，所以框架需要把上述的细节对使用者进行屏蔽，让他们感觉不到本地调用和远程调用的区别，所以需要代理实现。

然后还需要实现集群功能，因此要服务发现、注册等功能，所以需要注册中心，当然细节还是需要屏蔽的。

最后还需要一个完善的监控机制，埋点上报调用情况等等，便于运维。

这样一个 RPC 框架的雏形就差不多了。

## 10、Dubbo的安全机制

Dubbo通过Token令牌防止用户绕过注册中心直连，然后在注册中心上管理授权。

Dubbo还提供服务黑白名单，来控制服务所允许的调用方。



[原文链接](https://mp.weixin.qq.com/s/2qSA6aJn6KRXrATVE44k0w)













